// –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π supabaseClient.js —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π MetricsService
// –ó–∞–º–µ–Ω–∏—Ç–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ src/supabaseClient.js

import { createClient } from '@supabase/supabase-js';
import Papa from 'papaparse';

const supabaseUrl = process.env.REACT_APP_SUPABASE_URL;
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    storageKey: 'supabase.auth.token',
    storage: window.localStorage,
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
export const userService = {
  // –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  async getUserProfile(userId) {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();
    
    if (error) throw error;
    return data;
  },

  // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–∏–º –ª–∏–¥–æ–≤)
  async createUser(userData) {
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email: userData.email,
      password: userData.password,
      options: {
        data: {
          name: userData.name,
          role: userData.role
        }
      }
    });

    if (authError) throw authError;

    if (authData.user) {
      const { error: profileError } = await supabase
        .from('users')
        .insert([
          {
            id: authData.user.id,
            email: userData.email,
            name: userData.name,
            role: userData.role,
            created_at: new Date().toISOString()
          }
        ]);

      if (profileError) throw profileError;
    }

    return authData;
  },

  // –£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  async deleteUser(userId) {
    await supabase.from('tables').delete().eq('user_id', userId);
    await supabase.from('creatives').delete().eq('user_id', userId);
    
    const { error } = await supabase
      .from('users')
      .delete()
      .eq('id', userId);
    
    if (error) throw error;
  },

  // –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  async updateUserProfile(userId, updates) {
    const { data, error } = await supabase
      .from('users')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', userId)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // –ó–∞–≥—Ä—É–∑–∏—Ç—å –∞–≤–∞—Ç–∞—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  async uploadAvatar(userId, file) {
    try {
      const fileExt = file.name.split('.').pop();
      const fileName = `${userId}/avatar.${fileExt}`;

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª –≤ Supabase Storage
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('avatars')
        .upload(fileName, file, {
          upsert: true
        });

      if (uploadError) throw uploadError;

      // –ü–æ–ª—É—á–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–π URL
      const { data: { publicUrl } } = supabase.storage
        .from('avatars')
        .getPublicUrl(fileName);

      // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const updatedUser = await this.updateUserProfile(userId, {
        avatar_url: publicUrl
      });

      return updatedUser;
    } catch (error) {
      throw error;
    }
  },

  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –±–∞–π–µ—Ä–æ–≤
  async getAllBuyers() {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('role', 'buyer')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data;
  },

  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
  async getAllUsers() {
    try {
      console.log('üì° –ó–∞–ø—Ä–æ—Å –∫ —Ç–∞–±–ª–∏—Ü–µ users...');
      
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .order('created_at', { ascending: false });
      
      if (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –≤ getAllUsers:', error);
        console.error('üìã –î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', {
          code: error.code,
          message: error.message,
          details: error.details
        });
        throw error;
      }
      
      const result = data || [];
      console.log('‚úÖ getAllUsers –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ, –ø–æ–ª—É—á–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', result.length);
      
      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–∫–æ–ª—å–∫–æ –º–æ–Ω—Ç–∞–∂–µ—Ä–æ–≤ –Ω–∞–π–¥–µ–Ω–æ
      const editors = result.filter(u => u.role === 'editor');
      console.log('üë• –ù–∞–π–¥–µ–Ω–æ –º–æ–Ω—Ç–∞–∂–µ—Ä–æ–≤:', editors.length);
      
      return result;
      
    } catch (error) {
      console.error('üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ getAllUsers:', error);
      return [];
    }
  }
};

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–∞–±–ª–∏—Ü–∞–º–∏
export const tableService = {
  // –ü–æ–ª—É—á–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  async getUserTable(userId) {
    const { data, error } = await supabase
      .from('tables')
      .select('*')
      .eq('user_id', userId)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data;
  },

  // –°–æ–∑–¥–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É –∏–∑ CSV
  async createTableFromCSV(userId, csvContent) {
    try {
      // –ü–∞—Ä—Å–∏–º CSV
      const parsedData = Papa.parse(csvContent, {
        header: false,
        skipEmptyLines: true,
        delimiter: ';'
      });

      if (!parsedData.data || parsedData.data.length === 0) {
        throw new Error('CSV —Ñ–∞–π–ª –ø—É—Å—Ç –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ—à–∏–±–∫–∏');
      }

      // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å —Ç–∞–±–ª–∏—Ü—ã
      const { data: tableData, error: tableError } = await supabase
        .from('tables')
        .upsert([
          {
            user_id: userId,
            html_content: null,
            css_content: null,
            updated_at: new Date().toISOString()
          }
        ], {
          onConflict: 'user_id'
        })
        .select()
        .single();

      if (tableError) throw tableError;

      // –ü–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —è—á–µ–π–∫–∏
      const { error: deleteError } = await supabase
        .from('cells')
        .delete()
        .eq('table_id', tableData.id);

      if (deleteError) throw deleteError;

      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —è—á–µ–π–∫–∏ –∏–∑ CSV –¥–∞–Ω–Ω—ã—Ö
      const cellsToInsert = [];
      
      parsedData.data.forEach((row, rowIndex) => {
        row.forEach((cellValue, colIndex) => {
          if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
            cellsToInsert.push({
              table_id: tableData.id,
              row_index: rowIndex,
              column_index: colIndex,
              value: String(cellValue).trim(),
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            });
          }
        });
      });

      // –í—Å—Ç–∞–≤–ª—è–µ–º —è—á–µ–π–∫–∏ –±–∞—Ç—á–∞–º–∏
      if (cellsToInsert.length > 0) {
        const batchSize = 1000;
        for (let i = 0; i < cellsToInsert.length; i += batchSize) {
          const batch = cellsToInsert.slice(i, i + batchSize);
          const { error: cellsError } = await supabase
            .from('cells')
            .insert(batch);
          
          if (cellsError) {
            console.error('Error inserting cells batch:', cellsError);
            throw cellsError;
          }
        }
      }

      return tableData;
    } catch (error) {
      console.error('Error creating table from CSV:', error);
      throw error;
    }
  },

  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã
  async getAllTables() {
    const { data, error } = await supabase
      .from('tables')
      .select(`
        *,
        users(name, email)
      `)
      .order('updated_at', { ascending: false });
    
    if (error) throw error;
    return data;
  }
};

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —è—á–µ–π–∫–∞–º–∏
export const cellService = {
  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —è—á–µ–π–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
  async getTableCells(tableId) {
    const { data, error } = await supabase
      .from('cells')
      .select('*')
      .eq('table_id', tableId)
      .order('row_index')
      .order('column_index');
    
    if (error) throw error;
    return data;
  },

  // –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è AG Grid
  async getTableDataForGrid(tableId) {
    const cells = await this.getTableCells(tableId);
    
    if (cells.length === 0) {
      return { columnDefs: [], rowData: [] };
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —Ç–∞–±–ª–∏—Ü—ã
    const maxRow = Math.max(...cells.map(cell => cell.row_index));
    const maxCol = Math.max(...cells.map(cell => cell.column_index));

    // –°–æ–∑–¥–∞–µ–º –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤
    const grid = Array(maxRow + 1).fill(null).map(() => Array(maxCol + 1).fill(''));

    // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–µ—Ç–∫—É –¥–∞–Ω–Ω—ã–º–∏
    cells.forEach(cell => {
      grid[cell.row_index][cell.column_index] = cell.value;
    });

    // –°–æ–∑–¥–∞–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–æ–ª–æ–Ω–æ–∫ –∏–∑ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏
    const columnDefs = [];
    if (grid.length > 0) {
      grid[0].forEach((header, index) => {
        columnDefs.push({
          headerName: header || `–ö–æ–ª–æ–Ω–∫–∞ ${index + 1}`,
          field: `col_${index}`,
          editable: true,
          minWidth: 100,
          flex: 1,
          cellStyle: { 
            fontSize: '11px',
            padding: '2px 4px' 
          }
        });
      });
    }

    // –°–æ–∑–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫ (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏)
    const rowData = [];
    for (let i = 1; i < grid.length; i++) {
      const rowObj = {};
      grid[i].forEach((cellValue, colIndex) => {
        rowObj[`col_${colIndex}`] = cellValue;
      });
      rowData.push({
        ...rowObj,
        _rowIndex: i
      });
    }

    return { columnDefs, rowData };
  },

  // –û–±–Ω–æ–≤–∏—Ç—å —è—á–µ–π–∫—É
  async updateCell(tableId, rowIndex, columnIndex, value) {
    try {
      // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –æ–±–Ω–æ–≤–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —è—á–µ–π–∫—É
      const { data: existingCell, error: selectError } = await supabase
        .from('cells')
        .select('id')
        .eq('table_id', tableId)
        .eq('row_index', rowIndex)
        .eq('column_index', columnIndex)
        .single();

      if (existingCell) {
        // –Ø—á–µ–π–∫–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –æ–±–Ω–æ–≤–ª—è–µ–º
        const { data, error } = await supabase
          .from('cells')
          .update({
            value: String(value),
            updated_at: new Date().toISOString()
          })
          .eq('id', existingCell.id)
          .select();

        if (error) throw error;
        return data;
      } else {
        // –Ø—á–µ–π–∫–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
        const { data, error } = await supabase
          .from('cells')
          .insert([
            {
              table_id: tableId,
              row_index: rowIndex,
              column_index: columnIndex,
              value: String(value),
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            }
          ])
          .select();

        if (error) throw error;
        return data;
      }
    } catch (error) {
      console.error('Error updating cell:', error);
      throw error;
    }
  },

  // –û–±–Ω–æ–≤–∏—Ç—å —è—á–µ–π–∫—É –ø–æ –ø–æ–ª—é AG Grid
  async updateCellByField(tableId, rowIndex, field, value) {
    const columnIndex = parseInt(field.replace('col_', ''));
    return this.updateCell(tableId, rowIndex, columnIndex, value);
  },

  // –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —è—á–µ–µ–∫
  subscribeToTableChanges(tableId, callback) {
    return supabase
      .channel(`table_${tableId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'cells',
          filter: `table_id=eq.${tableId}`
        },
        callback
      )
      .subscribe();
  },

  // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ CSV
  async exportTableToCSV(tableId) {
    const cells = await this.getTableCells(tableId);
    
    if (cells.length === 0) {
      return '';
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —Ç–∞–±–ª–∏—Ü—ã
    const maxRow = Math.max(...cells.map(cell => cell.row_index));
    const maxCol = Math.max(...cells.map(cell => cell.column_index));

    // –°–æ–∑–¥–∞–µ–º –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤
    const grid = Array(maxRow + 1).fill(null).map(() => Array(maxCol + 1).fill(''));

    // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–µ—Ç–∫—É –¥–∞–Ω–Ω—ã–º–∏
    cells.forEach(cell => {
      grid[cell.row_index][cell.column_index] = cell.value;
    });

    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ CSV
    return Papa.unparse(grid, {
      delimiter: ';',
      skipEmptyLines: false
    });
  }
};

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫—Ä–µ–∞—Ç–∏–≤–∞–º–∏
export const creativeService = {
  // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∫—Ä–µ–∞—Ç–∏–≤
  async createCreative(creativeData) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è - Supabase –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
    const { data, error } = await supabase
      .from('creatives')
      .insert([
        {
          user_id: creativeData.user_id,
          editor_name: creativeData.editor_name, // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è –º–æ–Ω—Ç–∞–∂–µ—Ä–∞
          article: creativeData.article,
          links: creativeData.links,
          link_titles: creativeData.link_titles || [],
          work_types: creativeData.work_types,
          cof_rating: creativeData.cof_rating // –î–æ–±–∞–≤–ª—è–µ–º COF –æ—Ü–µ–Ω–∫—É
          // created_at –∏ updated_at —É—Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ DEFAULT NOW()
        }
      ])
      .select();

    if (error) throw error;
    return data[0];
  },

  // –ü–æ–ª—É—á–∏—Ç—å –∫—Ä–µ–∞—Ç–∏–≤—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  async getUserCreatives(userId) {
    try {
      console.log('üì° –ó–∞–ø—Ä–æ—Å –∫—Ä–µ–∞—Ç–∏–≤–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', userId);
      
      const { data, error } = await supabase
        .from('creatives')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      
      if (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –≤ getUserCreatives:', error);
        throw error;
      }
      
      const result = data || [];
      console.log('‚úÖ getUserCreatives –∑–∞–≤–µ—Ä—à–µ–Ω, –ø–æ–ª—É—á–µ–Ω–æ –∫—Ä–µ–∞—Ç–∏–≤–æ–≤:', result.length);
      
      return result;
      
    } catch (error) {
      console.error('üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ getUserCreatives:', error);
      return [];
    }
  },

  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫—Ä–µ–∞—Ç–∏–≤—ã (–¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
  async getAllCreatives() {
    try {
      console.log('üì° –ó–∞–ø—Ä–æ—Å –∫ —Ç–∞–±–ª–∏—Ü–µ creatives...');
      
      const { data, error } = await supabase
        .from('creatives')
        .select(`
          *,
          users(name, email)
        `)
        .order('created_at', { ascending: false });
      
      if (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –≤ getAllCreatives:', error);
        console.error('üìã –î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', {
          code: error.code,
          message: error.message,
          details: error.details,
          hint: error.hint
        });
        throw error;
      }
      
      const result = data || [];
      console.log('‚úÖ getAllCreatives –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ, –ø–æ–ª—É—á–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π:', result.length);
      
      // –í—ã–≤–æ–¥–∏–º –ø—Ä–∏–º–µ—Ä –ø–µ—Ä–≤–æ–π –∑–∞–ø–∏—Å–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
      if (result.length > 0) {
        console.log('üìã –ü—Ä–∏–º–µ—Ä –∑–∞–ø–∏—Å–∏ –∫—Ä–µ–∞—Ç–∏–≤–∞:', {
          id: result[0].id,
          article: result[0].article,
          work_types: result[0].work_types,
          cof_rating: result[0].cof_rating,
          editor_name: result[0].editor_name,
          hasUsers: !!result[0].users
        });
      }
      
      return result;
      
    } catch (error) {
      console.error('üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ getAllCreatives:', error);
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –≤–º–µ—Å—Ç–æ null –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—à–∏–±–æ–∫
      return [];
    }
  },

  // –û–±–Ω–æ–≤–∏—Ç—å –∫—Ä–µ–∞—Ç–∏–≤
  async updateCreative(creativeId, updates) {
    const { data, error } = await supabase
      .from('creatives')
      .update({
        ...updates
        // updated_at –æ–±–Ω–æ–≤–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ —Ç—Ä–∏–≥–≥–µ—Ä
      })
      .eq('id', creativeId)
      .select();

    if (error) throw error;
    return data[0];
  },

  // –£–¥–∞–ª–∏—Ç—å –∫—Ä–µ–∞—Ç–∏–≤
  async deleteCreative(creativeId) {
    const { error } = await supabase
      .from('creatives')
      .delete()
      .eq('id', creativeId);
    
    if (error) throw error;
  },

  // –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫—Ä–µ–∞—Ç–∏–≤–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  subscribeToUserCreatives(userId, callback) {
    return supabase
      .channel(`user_creatives_${userId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'creatives',
          filter: `user_id=eq.${userId}`
        },
        callback
      )
      .subscribe();
  },

  // –ü–æ–ª—É—á–∏—Ç—å –∫—Ä–µ–∞—Ç–∏–≤—ã —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏ —Ä–µ–∫–ª–∞–º—ã (–Ω–æ–≤—ã–π –º–µ—Ç–æ–¥)
  async getCreativesWithMetrics(userId = null) {
    try {
      let query = supabase
        .from('creatives')
        .select(`
          *,
          users(name, email)
        `)
        .order('created_at', { ascending: false });

      if (userId) {
        query = query.eq('user_id', userId);
      }

      const { data, error } = await query;
      
      if (error) throw error;
      
      const result = data || [];
      console.log(`‚úÖ –ü–æ–ª—É—á–µ–Ω–æ ${result.length} –∫—Ä–µ–∞—Ç–∏–≤–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ—Ç—Ä–∏–∫`);
      
      return result;
      
    } catch (error) {
      console.error('üí• –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—Ä–µ–∞—Ç–∏–≤–æ–≤ —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏:', error);
      return [];
    }
  }
};

// –°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏ —Ä–µ–∫–ª–∞–º—ã (–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º API)
export const metricsService = {
  API_URL: "https://api.trll-notif.com.ua/adsreportcollector/core.php",
  DB_SOURCE: "facebook",
  TIMEZONE: "Europe/Kiev",

  /**
   * –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ SQL –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ –∏–º–µ–Ω–∏ –≤–∏–¥–µ–æ
   */
  buildAggregateSqlForVideo(videoName, source = null) {
    const escapedVideoName = this.sqlEscapeLiteral(videoName);
    const escapedSource = this.sqlEscapeLiteral(source || this.DB_SOURCE);
    
    return `
      SELECT
        COALESCE(SUM(valid), 0)                       AS leads,
        COALESCE(SUM(cost), 0)                        AS cost,
        COALESCE(SUM(clicks_on_link_tracker), 0)      AS clicks,
        COALESCE(SUM(showed), 0)                      AS impressions
      FROM ads_collection
      WHERE source='${escapedSource}' AND video_name='${escapedVideoName}'
    `;
  },

  /**
   * –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è SQL
   */
  sqlEscapeLiteral(str) {
    return String(str).replace(/'/g, "''");
  },

  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ API –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
   */
  async fetchFromDatabase(sql) {
    if (!/^(\s*select\b)/i.test(sql)) {
      throw new Error("–†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ SELECT-–∑–∞–ø—Ä–æ—Å—ã.");
    }

    const options = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify({ sql }),
    };

    try {
      const response = await fetch(this.API_URL, options);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: —Å–µ—Ä–≤–µ—Ä –ë–î –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω`);
      }

      const text = await response.text();
      if (!text || !text.trim()) {
        throw new Error("–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞ –ë–î");
      }

      let json;
      try {
        json = JSON.parse(text);
      } catch (e) {
        throw new Error("–ù–µ–≤–µ—Ä–Ω—ã–π JSON –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞ –ë–î: " + e.message);
      }

      if (json && typeof json === "object" && json.error) {
        throw new Error("–û—à–∏–±–∫–∞ –ë–î: " + json.error);
      }

      return Array.isArray(json) ? json : [];
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ –ë–î:', error);
      throw error;
    }
  },

  /**
   * –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∫ –æ–±—ä–µ–∫—Ç—É –∞–≥—Ä–µ–≥–∞—Ç–æ–≤
   */
  normalizeAggregateRow(dbResponse) {
    if (!dbResponse || dbResponse.length === 0) {
      return {
        leads: 0,
        cost: 0,
        clicks: 0,
        impressions: 0
      };
    }

    // –°–ª—É—á–∞–π A: –º–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤
    if (typeof dbResponse[0] === "object" && !Array.isArray(dbResponse[0])) {
      const row = dbResponse[0];
      return {
        leads: Number(row.leads) || 0,
        cost: Number(row.cost) || 0,
        clicks: Number(row.clicks) || 0,
        impressions: Number(row.impressions) || 0
      };
    }

    // –°–ª—É—á–∞–π B: [headers, ...rows]
    const headers = dbResponse[0];
    const dataRow = dbResponse[1] || [];
    const map = {};
    headers.forEach((h, i) => (map[h] = dataRow[i]));
    
    return {
      leads: Number(map.leads) || 0,
      cost: Number(map.cost) || 0,
      clicks: Number(map.clicks) || 0,
      impressions: Number(map.impressions) || 0
    };
  },

  /**
   * –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫
   */
  computeDerivedMetrics({ leads, cost, clicks, impressions }) {
    const fix2 = (x) => Number.isFinite(x) ? Number(x.toFixed(2)) : 0;
    
    const CPL = leads > 0 ? cost / leads : 0;
    const CTR = impressions > 0 ? (clicks / impressions) * 100 : 0;
    const CPC = clicks > 0 ? cost / clicks : 0;
    const CPM = impressions > 0 ? (cost / impressions) * 1000 : 0;

    return {
      leads,
      cost: fix2(cost),
      clicks,
      impressions,
      cpl: fix2(CPL),
      ctr_percent: fix2(CTR),
      cpc: fix2(CPC),
      cpm: fix2(CPM)
    };
  },

  /**
   * –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
   */
  formatMetrics(metrics) {
    const formatInt = (n) => String(Math.round(Number(n) || 0));
    const formatMoney = (n) => (Number(n) || 0).toFixed(2).replace(".", ",");
    const formatPercent = (n) => (Number(n) || 0).toFixed(2).replace(".", ",") + "%";

    return {
      leads: formatInt(metrics.leads),
      cpl: formatMoney(metrics.cpl),
      cost: formatMoney(metrics.cost),
      ctr: formatPercent(metrics.ctr_percent),
      cpc: formatMoney(metrics.cpc),
      cpm: formatMoney(metrics.cpm),
      clicks: formatInt(metrics.clicks),
      impressions: formatInt(metrics.impressions)
    };
  },

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤–∏–¥–µ–æ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
   */
  async getVideoMetrics(videoName) {
    if (!videoName || typeof videoName !== 'string') {
      throw new Error('–ù–∞–∑–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ');
    }

    try {
      console.log(`üîç –ü–æ–∏—Å–∫ –º–µ—Ç—Ä–∏–∫ –¥–ª—è –≤–∏–¥–µ–æ: "${videoName}"`);
      
      const sql = this.buildAggregateSqlForVideo(videoName, this.DB_SOURCE);
      const dbResponse = await this.fetchFromDatabase(sql);
      
      if (!dbResponse || dbResponse.length === 0) {
        console.log(`‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –º–µ—Ç—Ä–∏–∫ –¥–ª—è –≤–∏–¥–µ–æ: "${videoName}"`);
        return {
          found: false,
          error: '–ù–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö'
        };
      }

      const aggregates = this.normalizeAggregateRow(dbResponse);
      const metrics = this.computeDerivedMetrics(aggregates);
      const formatted = this.formatMetrics(metrics);
      
      console.log(`‚úÖ –ù–∞–π–¥–µ–Ω—ã –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –≤–∏–¥–µ–æ: "${videoName}"`, formatted);
      
      return {
        found: true,
        data: {
          raw: metrics,
          formatted: formatted,
          videoName: videoName,
          source: this.DB_SOURCE,
          updatedAt: new Date().toLocaleString('ru-RU', {
            timeZone: this.TIMEZONE,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
          })
        }
      };
    } catch (error) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç—Ä–∏–∫ –¥–ª—è –≤–∏–¥–µ–æ: "${videoName}"`, error);
      return {
        found: false,
        error: error.message
      };
    }
  },

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤–∏–¥–µ–æ (–±–∞—Ç—á–µ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞)
   */
  async getBatchVideoMetrics(videoNames) {
    if (!Array.isArray(videoNames)) {
      throw new Error('videoNames –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º');
    }

    console.log(`üîç –ë–∞—Ç—á–µ–≤—ã–π –ø–æ–∏—Å–∫ –º–µ—Ç—Ä–∏–∫ –¥–ª—è ${videoNames.length} –≤–∏–¥–µ–æ`);

    const results = await Promise.allSettled(
      videoNames.map(async (videoName, index) => {
        try {
          // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—Ç—å API
          if (index > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          const result = await this.getVideoMetrics(videoName);
          return {
            videoName,
            ...result
          };
        } catch (error) {
          return {
            videoName,
            found: false,
            error: error.message
          };
        }
      })
    );

    return results.map((result, index) => ({
      videoName: videoNames[index],
      ...(result.status === 'fulfilled' ? result.value : {
        found: false,
        error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ'
      })
    }));
  },

  /**
   * –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ –±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
   */
  extractVideoName(fileName) {
    if (!fileName) return '';
    
    // –£–±–∏—Ä–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –≤–∏–¥–µ–æ —Ñ–∞–π–ª–æ–≤
    const cleanName = fileName.replace(/\.(mp4|avi|mov|mkv|webm|m4v)$/i, '');
    return cleanName.trim();
  },

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ API
   */
  async checkApiStatus() {
    try {
      const testSql = "SELECT 1 as test LIMIT 1";
      await this.fetchFromDatabase(testSql);
      return { available: true };
    } catch (error) {
      return { 
        available: false, 
        error: error.message 
      };
    }
  }
};
